https://job.pinduoduo.com/interview/livecode/vwtuPgvk58758077
MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引（所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储）


1 面试题：Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？
可以的，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用

注册中心对等集群，任意一台宕掉后，会自动切换到另一台
注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯
服务提供者无状态，任一台 宕机后，不影响使用
服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复
2 dubbo连接注册中心和直连的区别
在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，
点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，

服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表
注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

3、Dubbo在安全机制方面是如何解决的
Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。

CAP定理
Consistency：一致性，这个和数据库ACID的一致性类似，但这里关注的所有数据节点上的数据一致性和正确性，而数据库的ACID关注的是在在一个事务内，对数据的一些约束。系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读取到最新值。
Availability：可用性，每一个操作总是能够在一定时间内返回结果。需要注意“一定时间”和“返回结果”。“一定时间”是指，系统结果必须在给定时间内返回。“返回结果”是指系统返回操作成功或失败的结果。
Partition Tolerance：分区容忍性，是否可以对数据进行分区。这是考虑到性能和可伸缩性

悲观锁和乐观锁
• 悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
• 乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition 机制的其实都是提供的乐观锁。
优缺点：像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行 Retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适


https://blog.csdn.net/qq_36435927/article/details/83895352
网络IO模型？什么是多路复用IO？select和epoll的差别？select具体过程？
五种网络模型
第一阶段：等待数据 wait for data
第二阶段：从内核复制数据到用户 copy data from kernel to user
1阻塞I/Oblocking I/O： 
就是我们常见的socket,监听端口收到消息进行处理，并把结果返回给客户端
执行I/O操作完成前会一直进行等待，不会将控制权交给程序。套接字默认为阻塞模式
应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示，程序继续执行

2、非阻塞I/Ononblocking I/O
 
非阻塞IO通过进程反复调用IO函数，与阻塞不同的是，调用IO函数后，内核会立刻返回一个错误的接口，该进程会不断去调用查询结果的函数recv()，直到收到正确的结果，在这个过程中进程是阻塞的
非阻塞模式套接字与阻塞模式套接字相比，不容易使用。使用非阻塞模式套接字，需要编写更多的代码，但是，非阻塞套接字在控制建立的多个连接，在数据的收发量不均，时间不定时，明显具有优势
 
3、I/O复用模型 I/O multiplexing (select and poll)
主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；
I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数
4、信号驱动I/O signal driven I/O (SIGIO)
首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据

5、异步I/O模型 asynchronous I/O (the POSIX aio_functions)
当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作

select、poll和epoll的区别和 IO多路复用模型讲解
 
select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
此时需知道两个概念：
所谓阻塞方式block，顾名思义，就是进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞，函数不能立即返回。
所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生，则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高。


epoll对于select和poll相比，显著优点是：
（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。
（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。


数据库的几种隔离级别：
READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。
READ COMMITTED（读已提交数据）：只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。
REPEATABLE READ（可重复读）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。
SERIALIZABLE（序列化）：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。

MySQL支持四种事务隔离级别，
其中REPEATABLE READ为默认事务隔离级别。



反射是一个很重要的概念，它可以把字符串映射到实例的变量或者实例的方法然后可以去执行调用、修改等操作。(反射就是把字符串反射成内存对象)它有四个重要的方法：
getattr 获取指定字符串名称的对象属性
setattr 为对象设置一个对象
hasattr 判断对象是否有对应的对象（字符串）
delattr 删除指定属性








链接：https://www.nowcoder.com/discuss/220417?type=0&order=0&pos=57&page=1
1. C++多态   
多态指的就是用同样的接口访问功能不同的函数，从而实现“一个接口，多种方法”。
静态绑定的多态的是通过函数的重载来实现的。动态绑定的多态是通过虚函数实现的
    
2.虚函数如何实现     
带有虚函数的类，编译器会为其额外分配一个虚函数表，里面记录的使虚函数的地址，当此类被继承时，子类如果也写了虚函数就在子类的虚函数表中将父类的函数地址覆盖，否则继承父类的虚函数地址。
实例化之后，对象有一个虚函数指针，虚函数指针指向虚函数表，这样程序运行的时候，通过虚函数指针找到的虚函数表就是根据对象的类型来指向的  

3. 智能指针有几种，shared_ptr类内的use_count存在哪里？   
智能指针的设计就是为了解决这样的问题 
智能指针与裸指针的最大不同就是智能指针管理它所指内存的生命周期，当一块内存不再被需要后，智能指针就会自动的释放它。
智能指针分为 shared_ptr（共享指针） 和 unique_ptr（独占指针）
共享指针 
是指由几个关联的共享指针共享一块内存，用use_count（引用计数）来表示有几个共享指针使用这块内存，只有当所有共享指针都不指向这块内存后，引用计数变0，这块内存才会被自动释放。
独占指针 
是指由一个指针独占一块内存，当独占指针不再指向这块内存时，自动将其释放。注意独占指针有个方法（u.release()）可以放弃对内存的控制权，并返回指向这块内存的指针（供其他指针使用），但并不释放内存。
弱指针 
同时标准库还定义了弱指针（weak_ptr），之所以称作弱指针是因为它并不控制所指内存的生存期，这一点与裸指针十分相似，但弱指针上定义了w.use_count、w.lock()等方法让我们在使用弱指针之前就知道所指内存有没有被释放，只有在内存没有被释放的时候我们才使用它，避免了裸指针的空悬指针错误。
————————————————
原文链接：https://blog.csdn.net/river_lethe/java/article/details/78733914    

4. 进程和线程，浏览器开启一个新的page，采用进程还是线程？   
进程是资源分配最小单位，线程是程序执行的最小单位；
进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；
CPU切换一个线程比切换进程花费小；
创建一个线程比进程开销小；
线程占用的资源要⽐进程少很多。
线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）
多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；
进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；
原文链接：https://blog.csdn.net/wsq119/java/article/details/82154305    

5. 手撕代码题：给一个N+1个数的数组，满足A[0]>A[1],A[N]>A[N-1]。最快的办法找到一个i， 满足A[i-1] ≥ A[i] ≤ A[i+1]    
int rotateMin(const vector<int>& A)
{
	if(A.empty())
		return -1;
	int n = A.size();
	if(n < 2)
		return A[0];
	if(A[0] < A[1])
		return A[0];
	if(A[n-1] < A[n-2])
		return A[n-1];
	int i = 0, j = n-1;
	int mid;
	while(A[i] >= A[j])
	{
		if(j - i == 1)
			return A[j];
		mid = (i + j) / 2;
		if(A[i] == A[mid] && A[mid] == A[j])
		{
			int minA = A[i];
			for(int k=i+1; k<=j; k++)
			{
				if(A[k] < minA)
					minA = A[k];
			}
			return minA;
		}
		if(A[mid] < A[i])
			j = mid;
		else if(A[mid] > A[j])
			i = mid;
	}
	return -1;
}   

列举排序算法，那个排序算法时间复杂度最低？为什么桶计数排序能做到线性时间

问面试官环节： 
1.C++岗位都做啥？ 
2.为啥没有PC端啊？ 



链接：https://www.nowcoder.com/discuss/225813?type=2

手撕代码：判断在旋转后数组是否是严格递增
	
	
手撕代码：严格递增旋转数组的最小值的下标
	
	
C++11有什么特性
	1. nullptr
nullptr 出现的目的是为了替代 NULL。用来区分空指针、0
    2. 类型推导
	 auto 和 decltype 这两个关键字实现了类型推导
	 auto 不能用于函数传参，不能用于推导数组类型
	 decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：decltype(表达式)   auto x = 1;
																															auto y = 2;
																															decltype(x+y) z;
	拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}

	3. 区间迭代 基于范围的 for 循环
	for(auto &i : arr) {    
        std::cout << i << std::endl;
   }
   4. 初始化列表
C++11 提供了统一的语法来初始化任意的对象  std::vector<int> v = {1, 2, 3, 4};

5. 尖括号 “>”  std::vector<std::vector<int>> wow;在传统 C++ 的编译器中，>>一律被当做右移运算符来进行处理，C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译
6. 类型别名模板
在传统 C++中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：
template< typename T, typename U, int value>
class SuckType {
public:
    T a;
    U b;
    SuckType():a(value),b(value){}
};
template< typename U>
typedef SuckType<std::vector<int>, U, 1> NewType; // 不合法
C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：
template <typename T>
using NewType = SuckType<int, T, 1>;    // 合法

7. 默认模板参数
我们可能定义了一个加法函数：
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y) {
    return x+y
}
但在使用时发现，要使用 add，就必须每次都指定其模板参数的类型。 
在 C++11 中提供了一种便利，可以指定模板的默认参数：
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
8. 构造函数
委托构造
C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：
继承构造
在继承体系中，如果派生类想要使用基类的构造函数，需要在构造函数中显式声明。 
假若基类拥有为数众多的不同版本的构造函数，这样，在派生类中得写很多对应的“透传”构造函数。如下：
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的构造函数版本
}；
struct B:A
{
  B(int i):A(i){}
  B(double d,int i):A(d,i){}
  B(folat f,int i,const char* c):A(f,i,e){}
  //......等等好多个和基类构造函数对应的构造函数
}；
C++11的继承构造：
struct A
{
  A(int i) {}
  A(double d,int i){}
  A(float f,int i,const char* c){}
  //...等等系列的构造函数版本
}；
struct B:A
{
  using A::A;
  //关于基类各构造函数的继承一句话搞定
  //......
}；
如果一个继承构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比透传基类各种构造函数更加节省目标代码空间。

9. Lambda 表达式
Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。
[ caputrue ] ( params ) opt -> ret { body; };
1) capture是捕获列表； 
2) params是参数表；(选填) 
3) opt是函数选项；可以填mutable,exception,attribute（选填） 
mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。 
exception说明lambda表达式是否抛出异常以及何种异常。 
attribute用来声明属性。 
4) ret是返回值类型（拖尾返回类型）。(选填) 
5) body是函数体。

10. 新增容器 std::array
std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。
std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array只需指定其类型和大小即可：
std::array<int, 4> arr= {1,2,3,4};

std::forward_list

std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。 
和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。

无序容器

C++11 引入了两组无序容器： 
std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。
无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)。

元组 std::tuple
元组的使用有三个核心的函数：
std::make_tuple: 构造元组    std::make_tuple(3.8, 'A', "张三");
std::get: 获得元组某个位置的值    auto student = get_student(0);     std::cout << "ID: 0, "<< "GPA: " << std::get<0>(student) << ", " << "成绩: " << std::get<1>(student) << ", "<< "姓名: " << std::get<2>(student) << '\n';
std::tie: 元组拆包    // 元组进行拆包   std::tie(gpa, grade, name) = get_student(1);


12. 语言级线程支持
std::thread 
std::mutex/std::unique_lock 
std::future/std::packaged_task 
std::condition_variable
代码编译需要使用 -pthread 选项

13. 右值引用和move语义
string(string&& that)   // string&& is an rvalue reference to a string   转移构造函数
{
data = that.data;
that.data = 0;
}   复制构造函数执行的是深度拷贝，因为源对象本身必须不能被改变。而转移构造函数却可以复制指针，把源对象的指针置空，这种形式下，这是安全的，因为用户不可能再使用这个对象了
std::move仅仅是简单地将左值转换为右值，它本身并没有转移任何东西。它仅仅是让对象可以转移

原文链接：https://blog.csdn.net/jiange_zh/java/article/details/79356417

final关键标识 ，主要是class 及virtual function
CPoint2D() = default;//告诉编译器强制生成
delete ,放在函数后面，表示函数不能被调用
	 
    
	

智能指针shared_ptr、unique_ptr应用场景
	更适合使用unique_ptr的场景：1.语义简单，即当你不确定使用的指针是不是被分享所有权的时候，默认选unique_ptr独占式所有权，当确定要被分享的时候可以转换成shared_ptr；
	2.unique_ptr效率比shared_ptr高，不需要维护引用计数和背后的控制块;3.unique_ptr用起来更顺畅，选择性更多，可以转换成shared_ptr和通过get和release定制化智能指针（custom smart pointer）
原文链接：https://blog.csdn.net/qq_22533607/java/article/details/82318595
	

shared_ptr的内部的count计数是否是线程安全的
1 同一个shared_ptr被多个线程“读”是安全的。
2 同一个shared_ptr被多个线程“写”是不安全的。
3 共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的。（可以通过原子函数完成。） ++操作和 - - 操作不是原子的操作 ，存在线程安全问题	
	

那调用shared_ptr指向的对象的方法是否是线程安全的
	它指向的对象不一定是线程安全的，因为智能指针指向的对象本身并不受它的管控
	

如何解决线程安全
	可以通过原子函数完成。
	

上题自己挖坑，讲到了一种硬件方式实现原子化。面试官:<atomic>这个了解吗？我：不了解。面试官详细的给我讲解了这个<atomic>，学到了。
	
	

怎么去解决内存泄漏这些问题，有哪些工具
	
	

写程序遇到问题，怎么去调试，有哪些方法

面试官人很好，面试更多像是聊天交流而不是面试，<atomic>给我详细讲解了一遍。 
最后反问环节，聊到了pdd后台技术栈，C++与Go的应用场景。
		

class CSingleton  {  public:  static CSingleton* GetInstance()  {       if ( m_pInstance == NULL )             m_pInstance = new CSingleton();       return m_pInstance;  }  private:      CSingleton(){};      static CSingleton * m_pInstance;  };
原文链接：https://blog.csdn.net/zhanghuaichao/java/article/details/79459130
class CSingleton    {    private:        CSingleton()          {        }    public:        static CSingleton * GetInstance()        {            static CSingleton instance;             return &instance;        }    };  

//多线程版
class Singleton  {  private:      static Singleton* m_instance;      Singleton(){}  public:      static Singleton* getInstance();  };    Singleton* Singleton::getInstance()  {      if(NULL == m_instance)      {          Lock();//借用其它类来实现，如boost          if(NULL == m_instance)          {              m_instance = new Singleton;          }          UnLock();      }      return m_instance;  }  


6 然后说一下Redis吧，是单线程还是多线程，Redis的分布式怎么做，说了集群。
   单线程，多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU，因为CPU不是redis的瓶颈，redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个实例来解决。
   
   redis的持久化方案RDB和AOF
RDB：快照形式，定期把内存中的当前时刻的数据保存到磁盘中，redis默认支持的持久化方案，速度快，但是服务器断电的时候有可能丢失部分数据。
AOF：就是将所有对redis操作的命令，crud的命令，保存到一个文件中，数据库恢复的时候，将所有的命令执行一遍就可以了，速度慢，不过数据比较完整，与RDB同时开启的时候，会使用AOF来恢复数据。建议两个同时使用。

7 RPC了解么，我说了主要是协议栈+数据格式+序列化方式，然后需要有服务注册中心管理生产者和消费者，他问我注册中心宕机怎么办，我说可以做高可用，他说要问的不是这个，是想问我注册中心宕机时消费者是否能访问生产者。
我说消费者本地有缓存，可以访问缓存中的生产者。

9 TCP三次握手的过程，如果没有第三次握手有什么问题。
三面：技术面
1 自我介绍
2 讲一下项目的主要架构，你在里面做了什么
3 有什么比较复杂的业务逻辑讲一下。
4 最大的难点是什么，收获是什么。
5 MySQL的主从复制怎么做的，答日志，具体原理是什么，有什么优缺点。
6 Redis了解哪些内容，是单线程么，为什么是单线程呢，数据一定是存在物理内存中么，我不懂这话啥意思，就问了一下是不是指可能也在虚拟内存中。他说那讲一下虚拟内存的机制把，我就讲了分页，页表，换页这些东西。
7 项目用到了多线程，如果线程数很多会怎么样，我说会占内存，还有就是切换线程比较频繁，他问切换线程会发生什么，应该就是CPU切换上下文，具体就是寄存器和内存地址的刷新。
8 计算机如何访问一个文件的字节流呢，讲一下过程，说了Linux从inode节点找到磁盘地址，进行读取，他问我是直接读取么，我就说还会有读缓存，其实还应该说一下DMA的。
问了我知道swap分区么，我说不太清楚。
(系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据)
9 分布式了解哪些东西，消息队列了解么，用在什么场景，说了削峰，限流和异步。说了kafka，问我怎么保证数据不丢失，以及确保消息不会被重复消费。还问了消息送达确认是怎么做的。
10 cap了解么，分别指什么，base呢，强一致性和弱一致性有什么方法来做，2pc了解么，说一下大概过程。
11 负载均衡怎么做的呢，为什么这么做，了解过集群雪崩么。
12 这样一个题目，一个节点要和客户连接建立心跳检测，大概有百万数量的连接，并且会定期发送心跳包，要写一个update方法和check方法，update方法更新心跳状态，check删除超时节点，怎么做，刚开始做了个hash发现check要轮询太慢了，然后用计时器和开线程检测也不行，最后说了个LRU，他说OK的。
13 写一道题，二叉树的后序遍历，非递归算法。
用一个栈可以实现，先压自己，再压右节点，再压左节点。不过我卡在一半没写完，面试官说有思路就行了，今天就面到这，然后就溜了，发现已经没人了。
struct TreeNode
{
	int val;
	struct TreeNode* left;
	struct TreeNode* right;
	TreeNode(int value): val(value), left(NULL), right(NULL)
	{}
};
void postOrder(TreeNode* root, vector<int>& res)
{
	if(root)
	{
		if(root->left)
			postOrder(root->left, res);
		if(root->right)
			postOrder(root->right, res);
		res.push_back(root->val);
	}
}
void postOrder(TreeNode* root, vector<int>& res)
{
	if(root)
	{
		stack<pair<TreeNode*, int>> s;
		s.push(make_pair(root, 0));
		TreeNode* node = NULL;
		int times = 0;
		while(!s.empty())
		{
			node = s.top().first;
			times = s.top().second;
			s.pop();
			if(times == 1)
			{
				res.push_back(node->val);
			}
			else
			{
				s.push(make_pair(node, 1));
				if(node->right)
					s.push(make_pair(node->right, 0));
				if(node->left)
					s.push(make_pair(node->left, 0));
			}
		}
	}
}


链接：https://www.nowcoder.com/discuss/428156?type=0&order=0&pos=31&page=1&channel=-2&source_id=discuss_center_0
一面：
算法： 具体啥忘了， 反正就是一个树递归的样子，比较简单
ELK, zipkin, hystrix滑动窗口(基于错误率和流量)，ribbon负责均衡常用的算法


二面：
算法： 找区间内地波峰波谷： 其实就是一个肯定有至少一个极值读区间，如何快速找到之后任意一个极值(logN 二分)
事务 RR隔离级别具体实现： 
幻读(
读偏差: 只读事物 MVCC
写偏差: 2PL, SSI(基于冲突检测读乐观事物并发控制)
)
数据库自增主键ID的原因，顺序写入，避免B树页拆分(前提是非堆集表)
redis 大量过期key怎么删除? 单线程不能执行太久， 堆？
淘汰机制lru, ttl, random
cas的应用，高并发和高qps的区别？线程一定多吗？
高QPS需要的是no-blocking 而不是频繁的线程阻塞并切换，这样才适合cas进行同步
项目经验
MQ怎么处理消息重复(全局id的保存)，消息丢失(recon 统计)
吐槽项目: DBA保守，用geode， 规则引擎扩展性不高，描述能力过时

三面：
数据仓库项目中用了什么技术?
发行版（CDH这一套）hive, sparkSQL, impala

hive和impala 区别是使用场景： 可共享meta数据， 
hive是横向切分MR架构(模型更加通用，支持的数据格式更general, 当然速度肯定也慢)，适用于批处理job
impala是竖向切分MPP架构，有点交互式查询的味道，操作都在内存，且有数据格式优化(支持的数据格式少)，容错也低

最近开了什么比较有收获的书, 推荐一下，好在哪里？ ddia

hr：
想在哪里发展？
有没有女朋友？
有没有其他offer?


数据库查询语句如何执行？
1. DML语句首先进行语法分析，对使用sql表示的查询进行语法分析，生成查询语法分析树。
2.	语义检查：检查sql中所涉及的对象以及是否在数据库中存在，用户是否具有操作权限等
3.	视图转换：将语法分析树转换成关系代数表达式，称为逻辑查询计划；
4.	查询优化：在选择逻辑查询计划时，会有多个不同的表达式，选择最佳的逻辑查询计划；
5.	代码生成：必须将逻辑查询计划转换成物理查询计划，物理查询计划不仅能指明要执行的操作，也给出了这些操作的执行顺序，每步所用的算法，存储数据的方式以及从一个操作传递给另一个操作的方式。
6.	将DML转换成一串可执行的存取操作的过程称为束缚过程，
原文链接：https://blog.csdn.net/sinat_32176267/java/article/details/83280206

一、Http和Https的区别
　　Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
开销：Https通信需要证书，而证书一般需要向认证机构购买；  
Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

原文链接：https://blog.csdn.net/jiangshangchunjiezi/java/article/details/88545263


decltype和auto都可以用来推断类型，但是二者有几处明显的差异：
auto忽略顶层const，decltype保留顶层const；
对引用操作，auto推断出原有类型，decltype推断出引用；
对解引用操作，auto推断出原有类型，decltype推断出引用；
auto推断时会实际执行，decltype不会执行，只做分析。总之在使用中过程中和const、引用和指针结合时需要特别小心。


IO多路复用实现了多个IO操作复用一个线程。一个线程，跟踪多个 Socket 状态，哪个就绪，就读写哪个。
IO多路复用主要有select、poll、epoll三种模式，select/poll相差不大，主要是通过轮询来不断的检测是否有描述符已就绪，select默认情况下支持最多监控1024个描述符，poll则没有这个限制（底层通过链表实现，可动态增加）；epoll不是通过轮询，而是通过回调（callback）方式主动通知已有描述符已就绪，相比较select/poll效率有明显提升。
https://www.cnblogs.com/aspirant/p/9166944.html

select
1. 连接数限制：最大 FD（文件描述符）是有限制的，默认值是 1024/2048 ，因此Select模型的最大并发数就被相应限制了。
2. 线性扫描：select每次调用都会线性扫描全部的FD集合，这样效率就会呈现线性下降，把FD_SETSIZE改大的后果就是，都超时了。
3. 数据复制：内核 / 用户空间内存拷贝问题，如何让内核把FD消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法，在FD非常多的时候，非常的耗费时间。
总结：1、连接数受限 2、查找配对速度慢 3、数据由内核拷贝到用户态消耗时间
poll
1. 解决了连接数限制：poll 中将 select 中的 fd_set 替换成了一个 pollfd 数组，解决 fd 数量过小的问题。
2. 数据复制：用户空间和内核空间，复制连接就绪状态信息。
epoll
1. 事件机制：避免线性扫描，为每个 fd，注册一个监听事件，fd 变更为就绪时，将 fd 添加到就绪链表。
2. fd 数量：无限制（OS 级别的限制，单个进程能打开多少个 fd）。
3. 内存共享： Epoll 在这点上使用了“共享内存 ”，这个内存拷贝也省略了。
总结：把描述符列表的管理交由内核负责，一旦有某种事件发生，内核把发生事件的描述符列表通知给进程，避免轮询减少系统开销。
epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的文件描述符集合，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的文件描述符集合就行了。当描述符多的时候也只是会占用较多的内存而已，而不会造成占用大量cpu时间


https://blog.csdn.net/iteye_661/article/details/82405911
分页概念：逻辑空间分页，物理空间分块，页与块同样大，页连续块离散，用页号查页表，由硬件做转换，页面和内存块大小一般选为2的若干次幂（便于管理）
页表作用：实现从页号到物理地址的映射

段式管理的基本思想是：把程序按内容或过程（函数）关系分成段，每个段有自己的名字（编号）。一个作业或进程的虚拟存储空间都对应于一个由段号（段号：段内偏移）构成的二维地址，编译程序在编译链接过程中就直接形成这样的二维地址形式

分页与分段的主要区别

分页和分段有许多相似之处,比如两者都不要求作业连续存放.但在概念上两者完全不同,主要表现在以下几个方面:

(1)页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.

(2)页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.

(3)分页的作业地址空间是一维的.分段的地址空间是二维的


UDP报文的头部只有8个字节bai，相对TCP的20字节

TCP（TransmissionControl Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

 UDP是User Datagram Protocol，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。可靠性由上层应用实现，所以要实现udp可靠性传输，必须通过应用层来实现和控制
 

TCP如何实现可靠性传输？
         确认机制、重传机制、滑动窗口
		 
UDP 如何实现可靠传输：
  1、添加seq/ack机制，确保数据发送到对端。

2、添加发送和接收缓冲区，主要是用户超时重传。

3、添加超时重传机制

https://www.jianshu.com/p/2f7031a69f43
Cookie和Session的区别
1、存储位置不同  cookie的数据信息存放在客户端浏览器上   session的数据信息存放在服务器上
2、存储容量不同  单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie  
                 对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制
3、存储方式不同  cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据
                 session中能够存储任何类型的数据，包括且不限于string，integer，list，map等
4、隐私策略不同  cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的
                 session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险
5、有效期上不同  开发可以通过设置cookie的属性，达到使cookie长期有效的效果
                 session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果
6、服务器压力不同 cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择
                  session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存
7、浏览器支持不同 cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了
                  运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效
          cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效
		  session只能在本窗口以及子窗口内有效
8、跨域支持上不同   cookie支持跨域名访问   session不支持跨域名访问


select的几大缺点：

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大

（3）select支持的文件描述符数量太小了，默认是1024

poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。

MySQL
https://blog.csdn.net/Geffin/article/details/104043595

CREATE INDEX index_name ON table_name (column_list)

CREATE UNIQUE INDEX index_name ON table_name (column_list)

bit数组
https://blog.csdn.net/qq_37375427/article/details/79797359

冒泡： 适用的情景为数据量量不大，对稳定性有要求，且数据基本有序的情况下
选择： 当数据量不大，且对稳定性没有要求的时候
插入    最好的情况下即当数据有序时可以达到O(n)的时间复杂度，适用于数据量不大，对算法的稳定性有要求，且数据局部或者整体有序的情况
希尔    其排序的效率受到比较距离大小的影响。和插入排序的过程相似，相对于插入排序而言，比较较远距离的数据，使得数据移动跨过多个元素，进行一次比较可能会消除多个元素的交换
堆排序  实现原理是根据大顶堆或小顶堆得数据结构原理
归并    需要借助额外的存储空间，是高级排序算法中，唯一一个稳定的排序算法，当数据量较大时，要注意考虑内存空间的开销
快排： 空间复杂度为O(logn)到O(n)之间   常用于查找一组中前k大的数据
桶排序  桶排序的时间复杂度为O(n)，是一种简单快速的排序算法，也有较大的局限性，仅适用于数据的分布相对比较集中的时候，其原理是建立一个包含一定数目桶的表，将待排序的数据通过散列算法散列到桶中，然后再遍历桶的到有序的数据。

有序集合：集合里的元素可以根据key或index访问
.无序集合：集合里的元素只能遍历。
有序集合在属性的增加，删除及修改中拥有较好的性能表现


同步/异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 。
所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。
异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果

阻塞/非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

链接：https://www.zhihu.com/question/19732473/answer/241673170


迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。

数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite


阻塞、同步
• 阻塞：用户程序向操作系统提出IO请求，操作系统对于用户程序的请求是否立即返回，如果立即返回就是非阻塞的，如果不是立即返回的就是阻塞的；
• 同步：用户程序的读写操作是否暂停用户程序，如果用户程序停下手头的工作去忙活读写操作就是同步的，如果不用停下用户程序，操作系统就可以帮忙读写那就是异步的；
区别
• 阻塞 IO 和非阻塞 IO 的区别就在于：应用程序的调用是否立即返回！
• 同步 IO 和异步 IO 的区别就在于：数据拷贝的时候进程是否阻塞！