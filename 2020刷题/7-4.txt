283.移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

方法：双指针法
 过程：right - 扫描数组，指向当前元素
      left - 保存已经移至前面的非零元素位置，指向非零元素末尾，可以理解为当前找到的非零元素的个数。
类似partition方法： 21 调整数组顺序使奇数位于偶数前面
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left=0, right=0;
        int n = nums.size();
        while(right < n)
        {
            if(nums[right])
            {
                swap(nums[left++], nums[right++]);
            }
            else
                right++;
        }
    }
};


36.有效的数独
判断一个?9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字?1-9?在每一行只能出现一次。
数字?1-9?在每一列只能出现一次。
数字?1-9?在每一个以粗实线分隔的?3x3?宫内只能出现一次。


数独部分空格内已填入了数字，空白格用 '.' 表示。
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rowtable[9][9] = {0}, coltable[9][9] = {0}, blocktable[9][9] = {0};
        for(int i=0; i<9; i++)
        {
            for(int j=0; j<9; j++)
            {
                if(board[i][j] != '.')
                {
                    int k = i / 3 * 3 + j / 3;
                    int num = board[i][j] - '0' - 1;
                    if(rowtable[i][num] || coltable[j][num] || blocktable[k][num])
                        return false;
                    else
                        rowtable[i][num] = coltable[j][num] = blocktable[k][num] = 1;
                }
            }
        }
        return true;
    }
};
网络解答
方法：新建3个hash set，由于set中不能出现相同key值的元素，可以利用这点来判断
（题目中已经约定符号只有1-9和‘.’,所以问题较简单）
（用三个数组应该也可以实现，分别检查行、列、块）
*/
/*
class Solution
{
public:
??? bool isValidSudoku(vector<vector<char>>& board)
??? {
??????? for(int i = 0; i<9; i++)
??????? {
??????????? unordered_set<char> rowtable;
??????????? unordered_set<char> coltable;
??????????? unordered_set<char> blocktable;
???????????
?????????? // 某个block起始行列索引
?????????? // i = 0~2,r_b = 0,c_b = 0,3,6;
?????????? // i = 3~5,r_b = 3,c_b =0,3,6;
?????????? // i = 6~8,r_b = 6,c_b = 0,3,6.
??????????? int row_block = (i/3) * 3;
??????????? int col_block = (i%3) * 3;
???????????
??????????? for(int j = 0; j<9; j++)
??????????? {
??????????????? int a1 = board[i][j]; //第i行所有元素
??????????????? int a2 = board[j][i]; //第i列所有元素
??????????????? int a3 = board[row_block+j/3][col_block+j%3]; //j/3:0,0,0,1,1,1,2,2,2 j%3:0,1,2,0,1,2,0,1,2 用于遍历某一块（/号缓变，%号快变）
???????????????
??????????????? if(a1 !='.' && rowtable.find(a1) != rowtable.end()) return false; //检查行
??????????????? if(a2 !='.' && coltable.find(a2) != coltable.end()) return false; //检查列
??????????????? if(a3 !='.' && blocktable.find(a3) != blocktable.end()) return false; //检查块
???????????????
??????????????? rowtable.insert(a1);
??????????????? coltable.insert(a2);
??????????????? blocktable.insert(a3);
??????????? }
??????? }
??????? return true;
??? }
};*/
//方法：用三个数组，借助key-value的思想，将数字转化为索引，值为出现次数
class Solution
{
??? public:
??? bool isValidSudoku(vector<vector<char>>& board)
??? {
・?? ?? ? //每行中各元素出现次数统计，每列中各元素出现的次数统计，第二维表示数字（key）
??????? int rowtable[9][9] = {0}, coltable[9][9] = {0}, blocktable[9][9] = {0};
???????
??????? for(int i = 0; i< 9; i++)
??????? {
??????????? for(int j = 0; j<9; j++)
??????????? {
??????????????? if(board[i][j] != '.')
??????????????? {
??????????????????? int num = board[i][j] - '0' -1; //将数字与索引联系起来（索引以0开始）
??????????????????? int k = i/3*3 + j/3; //块索引，0~8，块每“大行”3个，故第一项要乘3，块坐标为（i/3,j/3）,若将board看成3*3
??????????????????? if(rowtable[i][num] || coltable[j][num] || blocktable[k][num])?
?? ??? ??? ??? ??? ??? ?return false;
? ? ? ? ? ? ? ? ? ??else
?? ??? ??? ??? ??? ??? ?rowtable[i][num] = coltable[j][num] = blocktable[k][num] = 1;
??????????????? }
??????????? }
??????? }
??????? return true;
???????
??? }
};

48.旋转图像
给定一个 n?×?n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。


思路：先验对角线翻转，再左右翻转
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<i; j++)
            {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n/2; j++)
            {
                swap(matrix[i][j], matrix[i][n-j-1]);
            }
        }
    }
};